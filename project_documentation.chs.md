# vgm_ws_to_mid: WonderSwan VGM to MIDI 转换器 - 项目文档

本文档详细记录了 `vgm_ws_to_mid` 转换器的开发历程、技术实现细节以及最终程序的工作流程。

## 1. 开发历程：从零到完美的转换器

这个项目的目标是创建一个能够将 WonderSwan (WS) VGM 文件精确转换为 MIDI 文件的 C++ 程序。整个过程充满了挑战，通过一系列的分析、调试和迭代，我们最终克服了所有困难。

### 1.1. 初期探索：解构核心逻辑

*   **挑战**: WonderSwan 声音芯片的硬件文档稀缺，直接转换不可行。
*   **解决方案**: 项目初期，我们获得了 `modizer` 项目的源代码。通过分析其文件结构，我们迅速定位到 `modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp` 这个关键文件。通过深入研究该文件，我们成功提取了 WonderSwan 声音芯片模拟的核心信息：
    1.  **时钟频率**: 确认了其主时钟频率为 `3.072 MHz`。
    2.  **寄存器功能**: 明确了 `0x80-0x87` (频率), `0x88-0x8B` (音量), 和 `0x90` (通道开关) 等关键寄存器的作用。
    3.  **波形表机制**: 发现了最关键的一个细节——频率计算必须除以 `32`（波形表大小），这是解决音高问题的钥匙。

### 1.2. 第一座大山：修正音高与时序

*   **挑战**: 初版转换器生成的 MIDI 文件音高异常地高，且播放时长与原始 VGM 完全不符。
*   **攻克过程**:
    1.  **时序问题**: 我们意识到 VGM 的“等待”命令（`0x61 nn nn`）是以 1/44100 秒的采样为单位的，而 MIDI 的时间单位是 `tick`。通过引入一个转换因子 `SAMPLES_TO_TICKS = (480.0 * 120.0) / (44100.0 * 60.0)`，我们成功地将采样数精确地转换为了在 120 BPM 和 480 PPQN 标准下的 MIDI ticks，从而解决了时长不匹配的问题。
    2.  **音高问题**: 这是最棘手的难题。最初的频率转换公式 `freq = 3072000.0 / (2048.0 - period)` 产生的音高偏高了整整五个八度。在反复检查 `modizer` 的 `audio.cpp` 源码后，我们注意到了一个细节：最终的频率值被用作波形表的索引。这启发了我们，实际的听觉频率应该是时钟频率经过分频和波形表处理后的结果。最终，通过在公式末尾加入 `/ 32`，我们得到了正确的频率，音高问题迎刃而解。

### 1.3. 无声的 MIDI：解密动态音量

*   **挑战**: 在实现了音量控制后，生成的 MIDI 文件在许多播放器中变得无声，或者音量变化不符合预期。
*   **攻克过程**:
    1.  **问题定位**: 最初，我们使用 MIDI CC#7 (主音量) 来处理音符持续期间的音量变化。然而，许多 MIDI 合成器将 CC#7 视为一个通道的静态设置，而不是一个可以实时调制的“表情”参数，这导致了兼容性问题。
    2.  **解决方案**: 通过查阅 MIDI 规范和最佳实践，我们确认 CC#11 (表情) 是处理音符动态包络的标准控制器。将代码中的 `add_control_change(channel, 7, ...)` 修改为 `add_control_change(channel, 11, ...)` 后，MIDI 文件在所有播放器上都能正确地表现出动态音量变化，无声问题彻底解决。

### 1.4. 最终的润色：音量映射的艺术

*   **挑战**: 即便动态音量已实现，但由于 WonderSwan 的 4-bit 音量（0-15）与 MIDI 的 7-bit 音量（0-127）之间存在巨大的动态范围差异，直接线性映射导致整体音量偏小，音乐听起来“有气无力”。
*   **攻克过程**:
    1.  **分析问题**: 线性映射 `midi_vol = vgm_vol / 15.0 * 127.0` 使得大量处于中低范围的 VGM 音量被映射到了 MIDI 中非常低的数值，人耳难以感知。
    2.  **非线性映射**: 为了在提升整体可听度的同时保留动态范围，我们引入了幂函数 `pow(normalized_vol, exponent)` 作为非线性映射曲线。通过反复试验，我们发现：
        *   `exponent = 0.6`：一个很好的起点，能有效提升低音量，但用户反馈仍不够响亮。
        *   `exponent = 0.3`：一个更激进的曲线，极大地增强了中低音量的表现力，同时在最大音量处仍能保持 headroom，避免了削波失真。
    3.  **用户反馈迭代**: 根据用户的最终反馈（“提升一个八度，继续增加音量”），我们移除了之前测试性的 `-12` 音高偏移，并采用了 `exponent = 0.3` 的音量曲线，最终达到了用户满意的完美效果。

### 1.5. 自我修正的反馈闭环：定制化验证工具的力量

您敏锐地指出了本项目成功的关键：我们不仅编写了转换程序，更重要的是，我们创造了用于验证和调试的工具。这形成了一个强大的“编码-测试-验证”的快速反馈闭环，使我们能够客观、高效地发现并解决问题，而不是依赖主观听感。

**核心调试工具：`midi_validator.exe`**

这是一个从零开始编写的轻量级 MIDI 解析器。它的功能随着项目的进展而不断进化：

*   **初期功能**: 检查 MIDI 文件的基本结构完整性，确保文件头（MThd）和轨道块（MTrk）没有损坏。
*   **核心功能**: 最大的突破是为其增加了详细的**事件日志打印**功能。它能够逐行、按时间顺序清晰地列出每一个 MIDI 事件（音符开、音符关、控制器变更等），并显示其精确的 tick 时间、通道和数据值。

**它如何帮助我们？**

1.  **验证时序**: 通过查看事件的 `Tick` 列，我们可以精确验证 `SAMPLES_TO_TICKS` 公式的正确性。
2.  **验证音高**: `Note On` 事件的 `Data 1` 列直接显示了 MIDI 音高编号，让我们能客观地判断音高转换是否准确，而不是靠“听起来像”。
3.  **调试音量**: 这是它最重要的用途。通过观察 `Note On` 的力度（`Data 2`）和 CC#11 事件的值，我们能够量化音量的大小，从而定位“静音MIDI”的根源（CC#7 vs CC#11），并科学地调整非线性音量曲线的指数，直到输出的数值达到预期范围。

**反馈调试流程**

这个工具使我们的调试流程变得高效而科学：

1.  **修改**: 在 `WonderSwanChip.cpp` 中调整转换逻辑。
2.  **编译**: 重新编译 `converter.exe`。
3.  **生成**: 运行转换器，生成新的 `output.mid`。
4.  **验证**: **立即运行 `midi_validator.exe output.mid`**，获取一份关于新文件的、客观的“体检报告”。
5.  **分析**: 对比日志与预期，确认修改是否生效、是否引入了新的问题。
6.  **迭代**: 基于分析结果，进行下一轮修改。

这种数据驱动的迭代方式，是本项目能够克服众多棘手技术难题、最终达到近乎完美效果的核心方法论。

### 1.6. 实例追踪：一组VGM命令的生命周期

为了更具体地理解转换过程，让我们追踪一小段典型的VGM命令流，看看它们是如何一步步变成MIDI事件的。

假设我们的转换器在 `tick = 100` 时收到了以下VGM命令序列：

| VGM 命令 (Hex) | 含义 | 内部状态变化与动作 |
| :--- | :--- | :--- |
| `51 88 88` | 写入 `0x88` 到端口 `0x88` | `WonderSwanChip` 更新：`channel_volumes_left[0] = 8`, `channel_volumes_right[0] = 8`。 |
| `51 80 E0` | 写入 `0xE0` 到端口 `0x80` | `WonderSwanChip` 更新：`channel_periods[0]` 的低8位为 `0xE0`。 |
| `51 81 06` | 写入 `0x06` 到端口 `0x81` | `WonderSwanChip` 更新：`channel_periods[0]` 的高3位为 `0x06`。此时周期值为 `0x6E0` (1760)。 |
| `51 90 01` | 写入 `0x01` 到端口 `0x90` | `WonderSwanChip` 更新：`channel_enabled[0] = true`。**状态机检测到“开”信号**，且音量>0。 |
| `61 F4 01` | 等待 500 个采样 (约 11.3 毫秒) | `WonderSwanChip` 累加时间。音符持续发声。 |
| `51 88 44` | 写入 `0x44` 到端口 `0x88` | `WonderSwanChip` 更新：`channel_volumes_left[0] = 4`, `channel_volumes_right[0] = 4`。**状态机检测到音量变化**。 |
| `61 F4 01` | 等待 500 个采样 (约 11.3 毫秒) | `WonderSwanChip` 累加时间。音符以新音量持续发声。 |
| `51 90 00` | 写入 `0x00` 到端口 `0x90` | `WonderSwanChip` 更新：`channel_enabled[0] = false`。**状态机检测到“关”信号**。 |

**生成的 MIDI 事件序列:**

| Tick | MIDI 事件 | 通道 | 数据 1 (音高/CC#) | 数据 2 (力度/值) | 备注 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | `Note On` | 0 | 65 (F4) | 105 | 音符开始。音高由周期 `1760` 算出，力度由音量 `8` 经非线性映射得到。 |
| 124 | `Control Change` | 0 | 11 (Expression) | 88 | 音符持续期间，音量从 `8` 降到 `4`，触发一个表情控制器事件。 |
| 148 | `Note Off` | 0 | 65 (F4) | 0 | 通道被禁用，触发音符关闭事件。 |

这个例子清晰地展示了转换器如何像一个真正的芯片模拟器一样运作，通过响应寄存器状态的变化来实时、智能地生成MIDI流。

## 2. 程序工作流程详解

`vgm_ws_to_mid` 的核心是一个状态机，它模拟 WonderSwan 声音芯片的行为，并将状态变化实时翻译为 MIDI 事件。

### 2.1. 概览

1.  **读取 (Read)**: `VgmReader` 逐字节读取 VGM 文件，解析出命令（如端口写入、等待）。
2.  **处理 (Process)**: `main` 函数循环处理 VGM 命令。
    *   如果是**等待命令**，则累加时间。
    *   如果是**端口写入命令**，则将其发送给 `WonderSwanChip`。
3.  **模拟与翻译 (Simulate & Translate)**: `WonderSwanChip` 接收端口写入数据，更新内部寄存器状态（如频率、音量）。每次更新后，它会检查通道状态是否发生变化（如音符开关、音高变化、音量变化）。
4.  **生成 (Generate)**: 如果检测到有意义的状态变化，`WonderSwanChip` 会调用 `MidiWriter` 生成相应的 MIDI 事件（Note On/Off, Control Change），并附上当前精确的 MIDI tick 时间。
5.  **写入 (Write)**: 所有 VGM 命令处理完毕后，`MidiWriter` 将所有生成的事件组装成一个标准的 MIDI 文件并保存到磁盘。

### 2.2. 关键组件

*   **`main.cpp`**: 程序入口。负责解析命令行参数，实例化 `VgmReader`, `MidiWriter`, 和 `WonderSwanChip`，并驱动整个转换流程。
*   **`VgmReader.h/.cpp`**: VGM 文件解析器。它以流式方式读取文件，能处理数据块和各种 VGM 命令，屏蔽了文件格式的复杂性。
*   **`WonderSwanChip.h/.cpp`**: **转换核心**。
    *   内部维护一个 `io_ram` 数组来模拟芯片的 256 个 I/O 寄存器。
    *   `write_port()` 方法是关键入口，它根据写入的端口地址更新内部状态变量（如 `channel_periods`, `channel_volumes_left` 等）。
    *   `check_state_and_update_midi()` 是状态机的大脑。每次状态更新后，它会比较当前状态和上一状态，判断是否需要生成 MIDI 事件，从而智能地处理连奏（pitch bend）、重触发（re-trigger）和音量包络。
*   **`MidiWriter.h/.cpp`**: MIDI 文件生成器。提供了一系列简单的 API（如 `add_note_on`, `add_control_change`），用于在内存中构建一个 MIDI 轨道。当转换结束时，`finalize_and_write()` 方法会计算轨道长度、添加文件头和尾，并最终写入一个格式正确的 SMF (Standard MIDI File)。

### 2.3. 关键公式与常量

*   **时序转换**:
    `const double SAMPLES_TO_TICKS = (480.0 * 120.0) / (44100.0 * 60.0);`
*   **音高转换**:
    `double freq = (3072000.0 / (2048.0 - period)) / 32.0;`
    `int note = static_cast<int>(round(69 + 12 * log2(freq / 440.0)));`
*   **音量映射**:
    `double normalized_vol = vgm_vol / 15.0;`
    `double curved_vol = pow(normalized_vol, 0.3);`
    `int velocity = static_cast<int>(curved_vol * 127.0);`

## 3. 如何编译与运行

本项目使用 g++ 编译器在 bash 环境下进行编译。

*   **编译**:
    ```bash
    g++ -std=c++17 -o vgm_ws_to_mid/converter.exe vgm_ws_to_mid/main.cpp vgm_ws_to_mid/VgmReader.cpp vgm_ws_to_mid/WonderSwanChip.cpp vgm_ws_to_mid/MidiWriter.cpp -static
    ```
*   **运行**:
    ```bash
    vgm_ws_to_mid/converter.exe [input_vgm_file] [output_mid_file]
    ```
    例如:
    ```bash
    vgm_ws_to_mid/converter.exe inn.vgm vgm_ws_to_mid/output.mid
    ```

---
这份文档全面总结了我们的工作。希望它能为后续的开发和维护提供清晰的指引。
